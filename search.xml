<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java开发(长篇)</title>
      <link href="/2023/11/18/java/"/>
      <url>/2023/11/18/java/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Java-语法基础"><a href="#1、Java-语法基础" class="headerlink" title="1、Java 语法基础"></a>1、Java 语法基础</h1><h2 id="1-1-注释"><a href="#1-1-注释" class="headerlink" title="1.1 注释"></a>1.1 注释</h2><h3 id="1-1-1-单行注释"><a href="#1-1-1-单行注释" class="headerlink" title="1.1.1 单行注释"></a>1.1.1 单行注释</h3><p><code>//</code></p><blockquote><p>  开发标准中注明单行注释需在被注释语句上方另起一行,使用&#x2F;&#x2F;注释</p></blockquote><h3 id="1-1-2-多行注释"><a href="#1-1-2-多行注释" class="headerlink" title="1.1.2 多行注释"></a>1.1.2 多行注释</h3><p><code>/**/</code></p><p>使用频率不高,通常用于解释一段代码的作用</p><h3 id="1-1-3-文档注释"><a href="#1-1-3-文档注释" class="headerlink" title="1.1.3 文档注释"></a>1.1.3 文档注释</h3><p><code>/**</code></p><blockquote><p>  <code>/**</code>回车后IDEA自动补全下方的<code>*/</code>,例如</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * main 方法作为程序的入口</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><code>javadoc</code> 生成代码文件</p><p>在当前类目录下执行<code>javadoc BaseDao.java -encoding utf-8</code>,会生成一些html js文件, 打开其中的index.html查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正在加载源文件BaseDao.java...</span><br><span class="line">正在构造 Javadoc 信息...</span><br><span class="line">标准 Doclet 版本 11.0.20</span><br><span class="line">正在构建所有程序包和类的树...</span><br><span class="line">正在生成./cn/cybersd/dao/BaseDao.html...</span><br><span class="line">正在生成./cn/cybersd/dao/package-summary.html...</span><br><span class="line">正在生成./cn/cybersd/dao/package-tree.html...</span><br><span class="line">正在生成./constant-values.html...</span><br><span class="line">正在构建所有程序包和类的索引...</span><br><span class="line">正在生成./overview-tree.html...</span><br><span class="line">正在生成./index-all.html...</span><br><span class="line">正在构建所有类的索引...</span><br><span class="line">正在生成./allclasses-index.html...</span><br><span class="line">正在生成./allpackages-index.html...</span><br><span class="line">正在生成./deprecated-list.html...</span><br><span class="line">正在构建所有类的索引...</span><br><span class="line">正在生成./allclasses.html...</span><br><span class="line">正在生成./allclasses.html...</span><br><span class="line">正在生成./index.html...</span><br><span class="line">正在生成./help-doc.html...</span><br></pre></td></tr></table></figure><blockquote><p>  文档注释的注意事项:</p><ol><li>javadoc只能为public和protected修饰的字段方法和类生成文档, 如果不是public的话,javadoc会执行失败. 另外default和private会被忽视</li><li>文档注释中不要使用标题标签, 容易发送冲突</li><li>文档注释中可以插入一些@注解, 比如@version版本号 @author作者标识符</li></ol></blockquote><h3 id="1-1-4-注释规约"><a href="#1-1-4-注释规约" class="headerlink" title="1.1.4 注释规约"></a>1.1.4 注释规约</h3><ol><li>类 字段 方法必须使用文档注释</li><li>所有的抽象方法包括接口中的方法必须要用javadoc注释,除了返回值 参数 异常说明外, 还必须指出该方法做了什么, 实现了什么功能</li><li>所有类必须添加创建者和创建日期, 可以在IDEA中创建模板</li></ol><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311181631587.png" alt="image-20231118163127521"></p><ol start="4"><li>所有枚举类型字段必须要有注释, 说明每个数据项的用途</li><li>代码修改的同时, 注释也要进行相应的修改</li></ol><h2 id="1-2-数据类型"><a href="#1-2-数据类型" class="headerlink" title="1.2 数据类型"></a>1.2 数据类型</h2><blockquote><p>  “Java 是一种静态类型的编程语言,这意味着所有变量必须在使用之前声明好”</p></blockquote><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311181635110.png" alt="image-20231118163511057"></p><h3 id="1-2-1-比特和字节"><a href="#1-2-1-比特和字节" class="headerlink" title="1.2.1 比特和字节"></a>1.2.1 比特和字节</h3><ol><li>bit(比特) 简写成”b”, 二进制的一位就是1比特,也就是比特要么是0要么是1</li><li>Byte(字节) 通常来说一个英文字符是1字节,一个中文字符就是2字节,它与比特的转换为: 1Byte &#x3D; 8bit</li><li>1KB &#x3D; 1024Byte   1MB &#x3D; 1024KB  ……</li></ol><h3 id="1-2-2-基本数据类型"><a href="#1-2-2-基本数据类型" class="headerlink" title="1.2.2 基本数据类型"></a>1.2.2 基本数据类型</h3><ol><li>boolean(布尔)</li></ol><p>用于存储true和false,也就是真和假</p><ol start="2"><li>byte(字节)</li></ol><p>字节是有符号的,取值范围为:-128到127包含两者</p><ol start="3"><li>short</li></ol><p>范围:-32768到32767包含两者 </p><blockquote><p>  short类型在实际开发中用的比较少,通常使用int即可</p></blockquote><ol start="4"><li>int(整数型)</li></ol><p>取值范围:-2147483648到2147483647包含两者</p><blockquote><p>  如果没有特殊需求,整型数据就用int</p></blockquote><ol start="5"><li>long(长整型)</li></ol><p>取值范围-2^63到2^63-1包含两者,如果int存储不下,就用long</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">100000000000L</span>;</span><br></pre></td></tr></table></figure><blockquote><p>  为了和int作区分,long在声明的时候尾部要带上”L”</p></blockquote><ol start="6"><li>float(单精度浮点数)</li></ol><p>取值范围:1.4E-45到3.4E+38, float不适合用于精确的数值,例如金额</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14159f</span>;</span><br></pre></td></tr></table></figure><ol start="7"><li>double(双精度浮点数)</li></ol><p>取值范围:±4.9E-324到±1.7976931348623157E308</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">myDouble</span> <span class="operator">=</span> <span class="number">3.141592653589793</span>;</span><br></pre></td></tr></table></figure><blockquote><p>  在进行金融计算或需要精确小数计算的场景中,可以使用 BigDecimal 类来避免浮点数舍入误差。BigDecimal 可以表示一个任意大小且精度完全准确的浮点数</p><p>  在实际开发中,如果不是特别大的金额（精确到 0.01 元,也就是一分钱）,一般建议乘以 100 转成整型进行处理</p></blockquote><ol start="8"><li>char</li></ol><p>取值范围:0到65535,用于处理Unicode字符,占2字节存储空间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> = letterA =<span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>  字符字面量应该用单引号（’’）包围,而不是双引号（””）,因为双引号表示字符串字面量</p></blockquote><p><strong>扩展:</strong></p><ol><li>单精度和双精度</li></ol><p>单精度是1位符号位,8位指数,23位小数. 单精度通常占用4字节存储空间,精度大约6到9位有效数字</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311181702258.png" alt="image-20231118170206231"></p><p>双精度是1位符号位,11位指数,52位小数. 双精度通常占用8字节存储空间,精度大约15到17位有效数字</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311181702898.png" alt="image-20231118170216879"></p><blockquote><p>  一个数由若干位数字组成,其中影响测量精度的数字称作<strong>有效数字</strong>,也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地,指一个用小数形式表示的浮点数中,从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位</p></blockquote><ol start="2"><li>int和chat类型转换</li></ol><ul><li>强制类型转换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value_int</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">value_char</span> <span class="operator">=</span> (<span class="type">char</span>) value_int;</span><br><span class="line"><span class="comment">//输出A</span></span><br><span class="line">System.out.println(value_char);</span><br></pre></td></tr></table></figure><ul><li>Character.forDigit()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">radix</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">value_int</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//radix=10 表示十进制</span></span><br><span class="line"><span class="type">char</span> <span class="variable">value_char</span> <span class="operator">=</span> Character.forDigit(value_int, radix);</span><br><span class="line">System.out.println(value_char)</span><br></pre></td></tr></table></figure><ul><li>Integer</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value_int</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//使用 int 的包装器类型 Integer 的 toString() 方法+String 的 charAt() 方法转成 char</span></span><br><span class="line"><span class="type">char</span> <span class="variable">value_char</span> <span class="operator">=</span> Integer.toString(value_int).charAt(<span class="number">0</span>);</span><br><span class="line">System.out.println(value_char);</span><br></pre></td></tr></table></figure><ul><li>char转int(自动类型转换)</li></ul><p><code>int a = &#39;a&#39;;</code></p><ol start="3"><li>包装器类型</li></ol><blockquote><p>  包装器类型（Wrapper Types）是 Java 中的一种特殊类型,用于将基本数据类型（如 int、float、char 等）转换为对应的对象类型</p></blockquote><h3 id="1-2-3-引用数据类型"><a href="#1-2-3-引用数据类型" class="headerlink" title="1.2.3 引用数据类型"></a>1.2.3 引用数据类型</h3><p>String类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">basicGrammar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line">    <span class="keyword">static</span> String b;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">basicGrammar</span> <span class="variable">lv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">basicGrammar</span>();</span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        System.out.println(lv.a);</span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口和数组也是引用数据类型</p><p><strong>基本数据类型和引用数据类型的区别:</strong></p><ol><li>基本数据类型<ul><li>变量名指向具体数值</li><li>基本数据类型存储在栈上</li></ul></li><li>引用数据类型<ul><li>变量名指向的是存储对象的内存地址,在栈上</li><li>内存地址指向的对象存储在堆上</li></ul></li></ol><h2 id="1-3-堆和栈"><a href="#1-3-堆和栈" class="headerlink" title="1.3 堆和栈"></a>1.3 堆和栈</h2><p>堆(heap)是在程序运行是在内存中申请的空间(可以理解为动态的过程). 切记,不是在编译的时候,Java对象就放在这里</p><p>好处:当需要一个对象时,只需要通过new关键字写一行代码即可,当执行这行代码时,会自动在内存的堆区分配空间,更灵活</p><p>栈(stack)能够和CPU直接关联,访问速度更快</p><blockquote><p>  既然栈访问速度更快,为什么把对象放到堆里面呢?</p><p>  因为Java在编译时,必须明确的知道存储在栈里的东西的生命周期,否则无法释放旧内存来开辟新的内存空间存放引用</p></blockquote><p>左侧是栈,右侧是堆</p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311191441371.png" alt="image-20231119144120141" style="zoom:25%;" /><p>举个🌰:</p><p><code>String a = new String(&quot;栗子&quot;);</code></p><p>这段代码现在堆里创建了一个 栗子 字符串对象,然后把对象的引用a放到栈里</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311191445345.png" alt="image-20231119144530316"></p><h2 id="1-4-数据类型转换"><a href="#1-4-数据类型转换" class="headerlink" title="1.4 数据类型转换"></a>1.4 数据类型转换</h2><h3 id="1-4-1-自动类型转换"><a href="#1-4-1-自动类型转换" class="headerlink" title="1.4.1 自动类型转换"></a>1.4.1 自动类型转换</h3><p>通常在表达式求值期间,需要遵循一下规则:</p><ul><li>如果任何操作数是double类型,其他操作数将被转换为double类型</li><li>否则如果任何操作数是float类型,其他操作数将被转换为float类型</li><li>否则如果任何操作数是long类型,其他操作数将被转换为long类型</li><li>否则,所有操作数被转换为int类型</li></ul><p>从小(int)到大(long或double)的转换是安全的,因为大数据类型可以容纳</p><p>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.5</span>;</span><br><span class="line"><span class="comment">//结果2.5</span></span><br><span class="line">System.out.println(a+b);</span><br></pre></td></tr></table></figure><p>这种转换一般被称为”表达式中类型的自动提升”</p><p>自动类型提升有好处,也会有让人匪夷所思的错误</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="comment">//Type mismatch: cannot convert from int to byte</span></span><br><span class="line">b = b * <span class="number">2</span>; </span><br></pre></td></tr></table></figure><p>如上,第二行会报”类型不匹配:无法从int转换为byte”的错误,该程序试图将一个完全合法的byte类型的值存储给byte类型的变量,但是当计算的时候,操作数被自动提升为int型,这样表达式的结果现在是int型,不强制转换就不能被赋予成byte型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">b = (<span class="type">byte</span>) (b*<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>  char型比较特殊,byte和short不能自动转化为char,相反char也不能自动转换为byte和short</p></blockquote><h3 id="1-4-2-强制类型转换"><a href="#1-4-2-强制类型转换" class="headerlink" title="1.4.2 强制类型转换"></a>1.4.2 强制类型转换</h3><p>常用与:</p><ul><li>将较大的数据类型转换为较小的数据类型</li><li>将浮点数转换为整数</li><li>将字符类型转换为数值类型</li></ul><blockquote><p>  强制转换可能导致精度降低或者数据丢失</p></blockquote><p>double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">42.8</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) d;</span><br><span class="line"><span class="comment">// i = 42 丢失了小数点后的数值</span></span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><h2 id="1-5-java基本数据类型缓存池"><a href="#1-5-java基本数据类型缓存池" class="headerlink" title="1.5 java基本数据类型缓存池"></a>1.5 java基本数据类型缓存池</h2><blockquote><p>  <code>new Integer(18) 与 Integer.valueOf(18)</code></p><p>  前者每次都会新建一个对象,后者会使用缓存池中的对象,多次调用智慧取同一个对象的引用</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">18</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">18</span>);</span><br><span class="line"><span class="comment">//结果为false,因为new出来的是不同的对象</span></span><br><span class="line">System.out.println(x == y );</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">18</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">18</span>);</span><br><span class="line"><span class="comment">//结果为true,因为他们调用的都是同一对象,地址相同</span></span><br><span class="line">System.out.println(z == k);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> Integer.valueOf(<span class="number">300</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">p</span> <span class="operator">=</span> Integer.valueOf(<span class="number">300</span>);</span><br><span class="line"><span class="comment">//结果为false</span></span><br><span class="line">System.out.println(m == p);</span><br></pre></td></tr></table></figure><p><strong>如上代码中,为什么m&#x3D;&#x3D;p的输出为false?</strong></p><p>基本数据类型的包装类除了Float和Double之外,其他六个包装类(Byte Short Integer Long Character Boolean)都有常亮缓存池</p><blockquote><p>  Byte：-128<del>127,也就是所有的 byte 值<br>  Short：-128</del>127<br>  Long：-128~127<br>  Character：\u0000 - \u007F<br>  Boolean：true 和 false</p></blockquote><p>Integer类内部中内置了256个Integer类型的缓存数据,当使用-128~127之间时.会直接返回常量池中数据的引用,而不是创建对象,就像上面代码中&#96;&#96;z&#x3D;&#x3D;k<code>结果为true一样,但是当不在这个范围内时,就会创建新的对象,就像</code>m&#x3D;&#x3D;p&#96;结果为false</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//valueOf方法的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;=IntegerCache.low &amp;&amp; i &lt;=IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IntegerCache静态内部类的源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> Integer.IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展:其中的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查 IntegerCache 内部类中的 high 字段的值是否大于等于 127。</span></span><br><span class="line"><span class="comment">//这样的断言通常用于在开发和调试阶段中对程序的某些假设进行检查。在这个特定的情境中,可能是为了确保 IntegerCache 的范围覆盖了一些常见的整数值,以保证缓存的有效性。</span></span><br><span class="line"><span class="keyword">assert</span> Integer.IntegerCache.high &gt;= <span class="number">127</span>;</span><br></pre></td></tr></table></figure><blockquote><p>  使用数据类型缓存池可以有效提高程序的性能和节省内存开销,但需要注意的是,在特定的业务场景下,缓存池可能会带来一些问题,例如缓存池中的对象被不同的线程同时修改,导致数据错误等问题。因此,在实际开发中,需要根据具体的业务需求来决定是否使用数据类型缓存池</p></blockquote><h2 id="1-6-Java运算符"><a href="#1-6-Java运算符" class="headerlink" title="1.6 Java运算符"></a>1.6 Java运算符</h2><h3 id="1-6-1-算数运算符"><a href="#1-6-1-算数运算符" class="headerlink" title="1.6.1 算数运算符"></a>1.6.1 算数运算符</h3><blockquote><p>   加法（+）减法（-）乘法（*）除法（&#x2F;）取余（%）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">System.out.println(a / b);<span class="comment">//3</span></span><br><span class="line">System.out.println(a % b);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>在上面代码中,因为数字在程序中可以分为两种,一种是整型,一种是浮点型,<strong>整型和整型的运算结果就是整型</strong>,不会出现浮点型。否则,就会出现浮点型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">10.0</span> / <span class="number">0.0</span>); <span class="comment">// Infinity 无穷大</span></span><br><span class="line">System.out.println(<span class="number">0.0</span> / <span class="number">0.0</span>); <span class="comment">// NaN 不是一个数字</span></span><br><span class="line">System.out.println(<span class="number">10</span> / <span class="number">0</span>);    <span class="comment">//抛出异常</span></span><br></pre></td></tr></table></figure><p>自增(++) 自减(–)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前自增</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> ++x;</span><br><span class="line">System.out.println(y + <span class="string">&quot; &quot;</span> + x);<span class="comment">// 11 11</span></span><br><span class="line"><span class="comment">//后自增</span></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">y = x++;</span><br><span class="line">System.out.println(y + <span class="string">&quot; &quot;</span> + x);<span class="comment">// 10 11</span></span><br></pre></td></tr></table></figure><h3 id="1-6-2-关系运算符"><a href="#1-6-2-关系运算符" class="headerlink" title="1.6.2 关系运算符"></a>1.6.2 关系运算符</h3><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311191536123.png" alt="image-20231119153619037" style="zoom: 33%;" /><h3 id="1-6-3-位运算符"><a href="#1-6-3-位运算符" class="headerlink" title="1.6.3 位运算符"></a>1.6.3 位运算符</h3><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311191537668.png" alt="image-20231119153728584" style="zoom: 33%;" /><p>举个🌰:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap 在计算哈希值的时候</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-4-逻辑运算符"><a href="#1-6-4-逻辑运算符" class="headerlink" title="1.6.4 逻辑运算符"></a>1.6.4 逻辑运算符</h3><blockquote><p>  逻辑与运算符（&amp;&amp;）：多个条件中只要有一个为 false 结果就为 false<br>  逻辑或运算符（||）：多个条件只要有一个为 true 结果就为 true<br>  逻辑非运算符（!）：用来反转条件的结果,如果条件为 true,则逻辑非运算符将得到 false</p><p>  单逻辑与运算符（&amp;）：很少用，因为不管第一个条件为 true 还是 false，依然会检查第二个<br>  单逻辑或运算符（|）：也会检查第二个条件<br>  <strong>也就是说,&amp; 和 | 性能不如 &amp;&amp; 和 ||,但用法一样</strong></p></blockquote><h3 id="1-6-5-赋值运算符"><a href="#1-6-5-赋值运算符" class="headerlink" title="1.6.5 赋值运算符"></a>1.6.5 赋值运算符</h3><p>注意类型之间的转换</p><h3 id="1-6-6-三元运算符"><a href="#1-6-6-三元运算符" class="headerlink" title="1.6.6 三元运算符"></a>1.6.6 三元运算符</h3><p>用于代替if-else</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//如果?前面的条件为true,则结果为:前面的值,否则为:后面的值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> (a&lt;b)?a:b;</span><br></pre></td></tr></table></figure><h2 id="1-7-Java流程控制语句"><a href="#1-7-Java流程控制语句" class="headerlink" title="1.7 Java流程控制语句"></a>1.7 Java流程控制语句</h2><h3 id="1-7-1-if-else"><a href="#1-7-1-if-else" class="headerlink" title="1.7.1 if-else"></a>1.7.1 if-else</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//如果条件1为true,执行这段代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">//如果条件2为true,执行这段代码</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//以上条件均为false执行这段大吗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311191547187.png" alt="image-20231119154740118" style="zoom: 33%;" /><p><strong>if嵌套语句:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(外侧条件)&#123;    </span><br><span class="line">     <span class="comment">// 外侧条件为 true 时执行的代码 </span></span><br><span class="line">    <span class="keyword">if</span>(内侧条件)&#123;  </span><br><span class="line">        <span class="comment">// 内侧条件为 true 时执行的代码</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311191549100.png" alt="image-20231119154924035" style="zoom:25%;" /><h3 id="1-7-2-switch语句"><a href="#1-7-2-switch语句" class="headerlink" title="1.7.2 switch语句"></a>1.7.2 switch语句</h3><blockquote><p>  switch 语句用来<strong>判断变量与多个值之间的相等性</strong>. 变量的类型可以是 byte、short、int 或者 char,或者对应的包装器类型 Byte、Short、Integer、Character,以及字符串和枚举类型</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量) &#123;    </span><br><span class="line">  <span class="keyword">case</span> 可选值<span class="number">1</span>:    </span><br><span class="line">    <span class="comment">// 可选值1匹配后执行的代码;    </span></span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">// 该关键字是可选项,跳出switch循环</span></span><br><span class="line">  <span class="keyword">case</span> 可选值<span class="number">2</span>:    </span><br><span class="line">    <span class="comment">// 可选值2匹配后执行的代码;    </span></span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">// 该关键字是可选项</span></span><br><span class="line">    ......     </span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 该关键字是可选项     </span></span><br><span class="line">    <span class="comment">// 所有可选值都不匹配后执行的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-3-for循环语句"><a href="#1-7-3-for循环语句" class="headerlink" title="1.7.3 for循环语句"></a>1.7.3 for循环语句</h3><p>普通for循环语句:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始变量;条件;自增/自减)&#123;  </span><br><span class="line"><span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-each: 常用与遍历数组和集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素 : 数组或集合)&#123;</span><br><span class="line">  <span class="comment">//要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-4-while循环语句"><a href="#1-7-4-while循环语句" class="headerlink" title="1.7.4 while循环语句"></a>1.7.4 while循环语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件)&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do-while循环:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;<span class="keyword">while</span>(提交);</span><br></pre></td></tr></table></figure><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311191557182.png" alt="image-20231119155710102" style="zoom:25%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;do-while&quot;</span>);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//可以去掉if语句改为</span></span><br><span class="line">&#125;<span class="keyword">while</span>(i != <span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="1-7-5-break与continue"><a href="#1-7-5-break与continue" class="headerlink" title="1.7.5 break与continue"></a>1.7.5 break与continue</h3><blockquote><p>  break 关键字通常用于中断循环或 switch 语句,它在指定条件下中断程序的当前流程. 如果是内部循环,则仅中断内部循环</p></blockquote><blockquote><p>continue 关键字用于当需要在for循环或者while循环中立即跳转到下个循环时使用,如果循环是嵌套的则仅跳过当前循环</p></blockquote><ul><li><code>break</code> 用于终止整个循环。</li><li><code>continue</code> 用于跳过当前循环迭代的剩余部分，继续下一次迭代。</li></ul><h2 id="1-8-数组和字符串"><a href="#1-8-数组和字符串" class="headerlink" title="1.8 数组和字符串"></a>1.8 数组和字符串</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>M系列芯片安装安卓模拟器</title>
      <link href="/2023/11/18/macbook/20231118/"/>
      <url>/2023/11/18/macbook/20231118/</url>
      
        <content type="html"><![CDATA[<p>使用Android Studio安装</p><p>官网下载：<a href="https://developer.android.google.cn/studio?hl=zh-cn">https://developer.android.google.cn/studio?hl=zh-cn</a></p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180015586.png" alt="image-20231118001525482"></p><p>安装好后一路next（中间需要安装sdk可能需要一点点魔法，设置一下代理）</p><p>进入后随便建一个项目</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180017290.png" alt="image-20231118001741270"></p><p>进去后如图所示</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180018136.png" alt="image-20231118001854117"></p><p>随便选择一个型号</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180019471.png" alt="image-20231118001917446"></p><p>找一个版本，例如安卓10，需要点击旁边的箭头下载</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180019767.png" alt="image-20231118001958741"></p><p>去配置文件<code>~/.zshrc</code>中添加如下代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安卓模拟器去除只读</span></span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/cybersd/Library/Android/sdk</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$ANDROID_HOME</span>/emulator:<span class="variable">$ANDROID_HOME</span>/tools:<span class="variable">$ANDROID_HOME</span>/tools/bin:<span class="variable">$ANDROID_HOME</span>/cmdline-tools/latest:<span class="variable">$ANDROID_HOME</span>/cmdline-tools/latest/bin:<span class="variable">$ANDROID_HOME</span>/platform-tools:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><p>去这个目录中<code>/Users/用户名/Library/Android/sdk/emulator</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看模拟器名称</span><br><span class="line">./emulator -list-avds</span><br><span class="line">#启动模拟器</span><br><span class="line">./emulator -avd &#x27;Pixel_6_Pro_API_29&#x27; -writable-system</span><br></pre></td></tr></table></figure><p>现在我们不需要打开Android Studio了，把这个命令打包成应用程序，使用mac自带的“自动操作”app进行，新建一个应用程序文稿</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180024120.png" alt="image-20231118002407097"></p><p>搜索shell</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180024537.png" alt="image-20231118002431513"></p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180025626.png" alt="image-20231118002520599"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /Users/用户名/Library/Android/sdk/emulator &amp;&amp; ./emulator -avd &#x27;模拟器名称&#x27; -writable-system</span><br></pre></td></tr></table></figure><p>保存之后就会出现在启动台，之后就可以点击启动台的程序进入模拟器了</p><p>burpsuite导出一个证书</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180026227.png" alt="image-20231118002649198"></p><p>生成证书</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -inform der -in burp.der</span><br><span class="line">9a5ba575</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIDqDCCApCgAwIBAgIFAINAaMEwDQYJKoZIhvcNAQELBQAwgYoxFDASBgNVBAYT</span><br><span class="line">C1BvcnRTd2lnZ2VyMRQwEgYDVQQIEwtQb3J0U3dpZ2dlcjEUMBIGA1UEBxMLUG9y</span><br><span class="line">dFN3aWdnZXIxFDASBgNVBAoTC1BvcnRTd2lnZ2VyMRcwFQYDVQQLEw5Qb3J0U3dp</span><br><span class="line">Z2dlciBDQTEXMBUGA1UEAxMOUG9ydFN3aWdnZXIgQ0EwHhcNMTQwODE1MTUyODA1</span><br><span class="line">WhcNMzMwODE1MTUyODA1WjCBijEUMBIGA1UEBhMLUG9ydFN3aWdnZXIxFDASBgNV</span><br><span class="line">BAgTC1BvcnRTd2lnZ2VyMRQwEgYDVQQHEwtQb3J0U3dpZ2dlcjEUMBIGA1UEChML</span><br><span class="line">……………………………………</span><br><span class="line"></span><br><span class="line">#重命名成这串数字</span><br><span class="line">mv burp.der 9a5ba575.0</span><br></pre></td></tr></table></figure><p>burpsuite设置一下代理，使用本机IP，不要使用127.0.0.1</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180029459.png" alt="image-20231118002959432"></p><p>然后打开安卓模拟器备用着</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /Users/cybersd/Library/Android/sdk/platform-tools</span><br><span class="line">#模拟器必须开机后进行下列操作，每次重新打开都要执行一下</span><br><span class="line">./adb root</span><br><span class="line">./adb remount</span><br><span class="line">#把证书倒入到模拟器中</span><br><span class="line">./adb push /Users/用户名/Desktop/9a5ba575.0 /system/etc/security/cacerts/9a5ba575.0</span><br></pre></td></tr></table></figure><p>点一下连接wifi</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180033627.png" alt="image-20231118003321593"></p><p>模拟器内设置代理</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180034277.png" alt="image-20231118003412249"></p><p>测试一下</p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311180037196.png" alt="image-20231118003701157"></p><p>注意：每次重启模拟器之后都要执行一下倒入证书的操作哦</p>]]></content>
      
      
      <categories>
          
          <category> macbook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xray基本使用</title>
      <link href="/2023/11/08/tools/Xray/"/>
      <url>/2023/11/08/tools/Xray/</url>
      
        <content type="html"><![CDATA[<h1 id="Xray"><a href="#Xray" class="headerlink" title="Xray"></a>Xray</h1><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>爬虫爬取</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xray webscan --basic-crawler http://testphp.vulnweb.com --html-output vuln.html</span><br></pre></td></tr></table></figure><p><strong>被动扫描</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xray ws --listen 127.0.0.1:7777 --html-output proxy.html</span><br></pre></td></tr></table></figure><hr><h1 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h1><p><strong>漏洞扫描</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xray ws -u http://testphp.vulnweb.com --html-output report.html</span><br></pre></td></tr></table></figure><p><strong>批量poc</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xray ws -p /pentest/xray/pocs/\* --url-file target.txt --html-output report.html</span><br></pre></td></tr></table></figure><p><strong>指定poc</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xray ws -p <span class="string">&quot;./xxx.yml&quot;</span> -u http://example.com/?a=b</span><br></pre></td></tr></table></figure><p><strong>shiro</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xray webscan --plugins shiro --url-file target.txt --html-output x.html</span><br></pre></td></tr></table></figure><hr><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p><strong>burp 转发给 xray</strong></p><p>xray 监听 127.0.0.1:7777</p><p>burp Upstream Proxy Servers 中配置 127.0.0.1 7777 即可转发</p><p><strong>转发给 burp 查看流量</strong></p><p>burp 监听 127.0.0.1:8080</p><p>config.yaml 中配置 proxy: “<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a>“ ,在 burp 中查看流量即可</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞扫描 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1 Docker 运行amd64镜像</title>
      <link href="/2023/11/07/macbook/M1-Docker-Arm/"/>
      <url>/2023/11/07/macbook/M1-Docker-Arm/</url>
      
        <content type="html"><![CDATA[<p>如果你是Mac苹果电脑，在Docker上运行非arm架构镜像，则可以尝试如下解决方式。</p><p>启动命令加入 –platform linux&#x2F;amd64 即可。</p><p>例如：</p><blockquote><p> docker run -it –platform linux&#x2F;amd64 –name dgraph dgraph&#x2F;standalone:v21.03.0</p></blockquote><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311080000217.png" alt="e5308c9597464c68828588f0a9572b97-20221117161948010"></p><p><strong>实践尝试</strong></p><p><img src="https://blog-1303815224.cos.ap-beijing.myqcloud.com/202311080000218.png" alt="image-20221117162020909"></p>]]></content>
      
      
      <categories>
          
          <category> macbook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
